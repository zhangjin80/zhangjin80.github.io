<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[归并排序算法实现详细注释]]></title>
    <url>%2F2018%2F03%2F09%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E8%AF%A6%E7%BB%86%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[归并排序的思想：分而治之。把一个庞大的数列从中间切分成两个，再分别对这两个数列排序，排序完后再合并，效率会比直接排序高。 那进一步把左右两边不断切分下去，效率也就会越高，切到只剩下一个元素是就不用再进行排序了。这是递归的思想，这就是所谓的归。 合并思想：把一个无序数列，从中间分开，分成左右两边，并递归的对左边和右边进行切分，直到到只剩下一个元素，这时一个元素的序列是有序的，不要再排序了，只需要向上和其盘边的序列进行合并就行了这就是并。 这里整理了一份归并排序的代码并写了详细的注释。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class MergeSort&#123; public static void main(String[] args) &#123;// 初始化一个数组 int[] intArray = &#123;4,2,5,3,3,10,13,4,15,6,13,20,11&#125;; // 先打印未排序的数组 System.out.println(Arrays.toString(intArray)); // 归并排序 mergeSort(intArray); // 打印排序好了的数组 System.out.println(Arrays.toString(intArray)); &#125; public static void mergeSort(int a[])&#123; /** * 为什么要给定下标范围： * 要把一个序列分而治之，需要分别对他的左边和右边切分 */ mergesort(a,0,a.length-1); &#125; /** * 递归方法： * 递归的对数组进行对半切分 * @param a 要排序的数组 * @param first 要排序的数组起始位置 * @param last 要排序的数组的终止位置 * 以两个元素为例进行递归演示： * mergesort&#123;1,2&#125;,0,1 * mid = 0 * mergesort(&#123;1,2&#125;,0,0)---first=last出递归 * mergesort(&#123;1,2&#125;,1,1)---first=last出递归 * mergearray(&#123;1,2&#125;,0,0,1)---放入切分的中间标记，数组左右两边进行合并 */ private static void mergesort(int[] a, int first, int last) &#123; if(first&lt;last)&#123;//递归出口，first=last，只有一个元素时返回继续向下执行 /** * 为什么不能用a.leng/2呢？ * 在递归调用时传的是都是原始数组a，如果用leng的话mid值不会变， * 起不到切分的作用 */ int mid = (first+last)/2; mergesort(a,first,mid); mergesort(a,mid+1,last); mergearray(a,first,mid,last); &#125; &#125; /** * 合并方法： * 把一个数组切分后有序的两端进行合并 * @param a 原始数组 * @param first 要合并的左边数组的开始位置 * @param mid 切分点 * @param last 要合并的右边数组末尾位置 */ private static void mergearray(int[] a, int first, int mid, int last) &#123; /** * 临时数组用于存放有序元素 * 为什么不用int[a.length]创建？ * 因为每次合并的只是a的一部分而已，这样做可以节省空间 */ int[] temp = new int[last+1]; int i = first;//左边数组起始位置 int j = mid+1;//右边数组起始位置 int m = mid;//左边数组终止位置 int n = last;//右边数组终止位置 int k = 0;//临时数组的指针 /** * 比较两个数组栈顶元素大小，把小的存入临时数组 */ while(i&lt;=m&amp;&amp;j&lt;=n)&#123; if(a[i]&lt;=a[j]) temp[k++] = a[i++]; else temp[k++] = a[j++]; &#125; /** * 分别把两个数组剩下的元素存入临时数组 */ while(i&lt;=m)&#123; temp[k++]=a[i++]; &#125; while(j&lt;=n)&#123; temp[k++] = a[j++]; &#125; /** * 把临时数组的值赋给原来的数组 */ for(i=0;i&lt;k;i++)&#123; a[first+i] = temp[i]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序，二分查找，二维数组打印杨辉三角]]></title>
    <url>%2F2017%2F12%2F18%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%89%93%E5%8D%B0%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%2F</url>
    <content type="text"><![CDATA[插入排序。123456789101112131415161718192021222324//方式一：int arr = &#123;3,11,6,22,1,44&#125;;for(int i=1; i&lt;arr.length; i++)&#123; int temp = arr[i]; int j = i; while(j&gt;0&amp;&amp;arr[j-1]&gt;temp)&#123;//前面的数大于i处的值就往后覆盖，一直到temp的值比这个值小的时候停止 arr[j] = arr[j-1]; j--; &#125; arr[j] = temp;//把temp的值赋给前面元素比它大的位置&#125;//方式二for(int i = 1; i&lt;arr.length; i++)&#123; for(int j=0;j&lt;i;j++)&#123; if(arr[j]&gt;arr[i])&#123; int temp = arr[i]; for(int k=i;k&gt;j;k--)&#123; arr[k] = arr[k-1]; &#125; arr[j]=temp; &#125; &#125;&#125; 有序数组的二分查找。 123456789101112131415161718192021222324public class BinarySearch &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 5, 7, 12, 19, 22, 25, 29, 33&#125;; int start = 0; int end = arr.length-1; int middle; int value = 25; while (start&lt;end) &#123; middle = (start + end) / 2; if (arr[middle] == value) &#123; System.out.println(middle); break; &#125; if (arr[middle] &gt; value) &#123; end = middle-1; &#125; if (arr[middle] &lt; value) &#123; start = middle+1; &#125; &#125; &#125;&#125; 利用不规则的二维数组存储杨辉三角 1234567891011121314151617int[][] arr = new int[8][]; for(int i=0; i&lt;arr.length; i++)&#123; arr[i] = new int[i+1]; &#125; for(int i=0; i&lt;arr.length; i++)&#123; for(int j=0; j&lt;arr[i].length; j++)&#123; if(j==0||j==i)&#123; arr[i][j] = 1; System.out.print(arr[i][j]); &#125;else&#123; arr[i][j] = arr[i-1][j-1]+arr[i-1][j]; System.out.print(arr[i][j]); &#125; &#125; System.out.println(); &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎样做到100分]]></title>
    <url>%2F2017%2F09%2F26%2F%E6%80%8E%E6%A0%B7%E5%81%9A%E5%88%B0100%E5%88%86%2F</url>
    <content type="text"><![CDATA[现在很流行一万小时定律，就是你要在某个领域成为专家那只需要在这个领域经过一万小时的练习就可以了。那真的是这样的吗？真的需要一万小时吗？一万小时就会成为专家吗？其实这都不一定，就像一个出租车司机，已经积累了1万小时的里程但是他还是成为不了赛车手一样。罗辑思维的是这期节目告诉你到底应该怎么做才能练成一个高手。建议在原文链接里看完这期节目后再回来看这篇文章会收获更大。 刻意练习一、练习——针对性重复练习。 套路，拿来主义。 前人的知识封装成一个知识罐头，抽象为简洁的东西，拿来就用。最重要的套路： 行业经验，书本上找不到，而是行业前辈总结出的经验。找老司机学套路。 学科的概念，一个学科是靠几个大的概念堆出来的，要围绕着这些大的概念把他们弄清楚。经济学20世纪最重要的概念就是发现了交易成本，物理学是发现了熵。只要你了解这些概念清晰的内涵和外延，你就能把这个学科整坨的知识拿到手。 拆解练习。不能以赛代练，要要把大的知识体系拆碎成为一个个小模块，一个个小知识罐头，分别练习。 最重要的事是——重复。 二、刻意——持续做你不会做的事 三个区域的划分：舒适区—学习区—恐慌区 学习区：脱离舒适区。 农耕时代的勤奋苦练就能成为高手的技能如刀削面师傅等待在现代社会是简单技能，但是现在社会是分工合作的复杂体，要掌握的技能是综合性的复杂技能，不能一味停留在舒适区不能自拔。真正会读书的人是看对自己有挑战的书的人，这种人才是真正有效的。高手是不会让自己进入下意识状态。永远挑战意外永远不会允许自己失控。 被动的脱离舒适区，进入学习区 好的学习环境，是能获得即使反馈的环境。每一个微小的进步，外界环境都给你一个反馈告诉你对错，是否要继续练习。要建立即时反馈系统。 总结：学习的本质就是脱离舒服，没有轻松省力的捷径，学习注定是痛苦的。 三、学习的真相 互联网的信息结构是超文本连接而不是学习。他要人不断的做决策，做选择，而这些决策是被别人引诱而做出来的。（谷歌的核心战略的让用户快进快出），选择是由前额叶做出的，选择并不是在学习。 真正的学习是，不断把新的信息和自身原有的信息结构做缝接，高手的特点就是任何获得的新信息马上能和自己大脑中长期存储的记忆建立联系，信息群被迅速同时激活。做笔记是把学到的东西和自己的知识结构做缝接的过程。收藏的文字要写心得，这是为了与新知识形成互动，把新知识缝接到我原来的知识结构上。知识，是信息之间形成结构进入我们的大脑库存，这个库存不是装东西的存，而是一种体系结构，知识是一种生长出来带结构的东西。 怎样使用工具。有了互联网，人类让自己堕落的更浅薄。我们不能躺在工具产生的便利性上睡大觉挥霍时间在舒适区享受，而是要踏着新工具新技术进一步探索世界，开拓新边疆，向学习区进发。]]></content>
      <categories>
        <category>社会科学</category>
      </categories>
      <tags>
        <tag>人生</tag>
        <tag>刻意练习</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两种自由]]></title>
    <url>%2F2017%2F09%2F26%2F%E4%B8%A4%E7%A7%8D%E8%87%AA%E7%94%B1%2F</url>
    <content type="text"><![CDATA[精神自由liberal arts一词来源于西方属于西学，有的翻译叫“通识教育”、“素质教育”、“人文教育”、“博雅教育”等，但更确切的讲应该译作“自由技艺”。在古代她是统治者的学问，而在现代是一种培养具有批判性思维，独立人格的学问，也可以叫做拒绝被统治的学问。 这些学问和那些可以直接从事生产赚钱的技术不同，她们是一种软实力，这些软实力中最重要的有三个：批判性思维、交流、解决问题的能力。 批判性思维简单的讲就是对一件事有自己的主见。遇到一件事不随大流，不跟风，要经过调查分析，逻辑判断，多视角思考之后才得出自己的判断。 交流这里讲的是广义上的交流，包括表达自己思想，说服别人，演讲写作等等。在交流中要有自己的风格，也就是人格魅力，他是通过自由技艺的训练而获得的，它不单是个性，还要和别人产生共鸣。 解决问题的能力说的是当你现在遇到问题的时候你要能从你学习到众多知识中找到性质相似的案例，从而知道怎么很好的解决当下的问题。 有了批判性思维你能建立正确的认知。学会有风格的交流你能用你的认知影响别人，再加上一篮子解决问题的方法，那你将不再是一个工具而是一个独立的人了。 这些技艺并不是客观世界的科学，而是主观的体验和看法。他来源于各种人文、艺术学科。 所以，如果你只看专业书籍的话你最终还是工具，乞丐中的王者还是乞丐。只有加上人文和艺术你才能成为自由人。 财富自由怎么获得财富自由呢？一句话就是通过刻意练习，让你的一门手艺达到前5%。或者你把两项达到前25%的手艺组合起来使用。 那下面重点就是怎么样进行刻意练习了。 针对性重复练习。 套路，也就是拿来主义。 要站在前人的肩膀上，不要重复发明轮子。 最重要的套路有两种： 行业经验，书本上找不到，而是行业前辈总结出的经验。你需要找老司机学套路。 学科的概念，一个学科是靠几个大的概念堆出来的，要围绕着这些大的概念把他们弄清楚。比如，经济学20世纪最重要的概念就是发现了交易成本，物理学是发现了熵。只要你了解这些概念清晰的内涵和外延，你就能把这个学科整块的知识拿到手。 拆解练习。不能以赛代练，把大的知识体系拆成为一个个小模块，把复杂问题拆分成简单的小问题逐个攻破。这才有出路。 不断重复重复。 持续做你不会做的事人通常生活在三个区域的划分：舒适区、学习区、恐慌区。大多数人都是生活在舒适区的，但只有学习区才能使人进步，然而想要脱离舒适区是痛苦的。 主动脱离舒适区进入学习情。 刀削面师傅花哨的削面动作在现代只能算是熟练的简单技能，要掌握综合性的复杂技能，就不能一味停留在舒适区不能自拔。不要让自己进入下意识行动状态，要永远挑战意外，不要让自己失控，要时刻用理智指挥自己，强制进入学习区。 被动脱离舒适区进入学习区 好的学习环境，是能获得即使反馈的环境。每一个微小的进步，外界环境都给你一个反馈告诉你是对还是错？建立即时反馈系统，可以被动的让你进入学习区。 总之就是不断重复做你不会做的事，这是很挑战人性本能的活动，但是只要方法得当，你坚持上一段比较长的时间，人人都能做到。 按照马斯洛的需求理论，你必须先追求财富自由，才可能追求精神自由。但这不是绝对的，二者是相辅相成，在追求财富自由的间隙学习一点自由技艺，只会加快你实现财富自由的速度。另外，财富自由可以与生俱来，但精神自由是每个人都需要独立完成的。 我将会用一生的时间去追求这两项自由。]]></content>
      <categories>
        <category>成为你自己</category>
      </categories>
      <tags>
        <tag>人生</tag>
        <tag>自由</tag>
      </tags>
  </entry>
</search>
